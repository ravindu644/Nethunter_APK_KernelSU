#!/system/bin/sh

## Important note:
## Only works with exynos9820 devices with ravindu644's .rc file

SCRIPT_PATH=$(readlink -f $0)
. ${SCRIPT_PATH%/*}/bootkali_log
. ${SCRIPT_PATH%/*}/bootkali_env


USB_RC="/vendor/etc/init/init.$(getprop ro.hardware).usb.rc"

if grep -q "nethunter" "$USB_RC"; then
    bklog "[!] Custom Nethunter build by ravindu644 for exynos9820/9825."
else
    bklog "[-] This specific script will only work with ravindu644's custom usb.rc file."
    exit 1
fi

#################################
#### Define global variables ####
#################################
ORI_DWC=$(getprop sys.usb.controller)
DIR_CONFIGFS=/config/usb_gadget/g1
DIR_ALL_FUNCS=$DIR_CONFIGFS/functions
DIR_CUR_FUNCS=$DIR_CONFIGFS/configs/b.1


## Get what functions the user are using, and list them in ascending order.
ORI_FUNCS_UNSORT=($($BUSYBOX find $DIR_CUR_FUNCS -type l))
ORI_FUNCS=($(printf '%s\n' "${ORI_FUNCS_UNSORT[@]}" | $BUSYBOX sort -n))

## Make sure user at least has one usb functions enabled,
## otherwise it cannot be determined what prefix name and the first instance number should be used.
if [ -z "$ORI_FUNCS" ]; then
    bklog "[-] No symlinked function is found in $DIR_CUR_FUNCS, something is wrong, aborting.."
    exit 1
fi

## Seperate the prefix name and the instance order.
FUNCS_NAME_PREFIX=$(echo ${ORI_FUNCS[0]} | $BUSYBOX sed 's/\(^.*\)\(\/\([a-zA-Z]\{1,\}\)[0-9]\{1,\}$\)/\3/g')
FUNCS_NAME_ORDER=$(echo ${ORI_FUNCS[0]} | $BUSYBOX sed 's/\(^.*\)\(\/[a-zA-Z]\{1,\}\([0-9]\{1,\}\)$\)/\3/g')

## Define the first function name that will be symlinked to $DIR_CUR_FUNCS
SYMLINK_FUNC_NAME="${FUNCS_NAME_PREFIX}${FUNCS_NAME_ORDER}"

################################
#### Define shell functions ####
################################

function print_usage(){
    bklog "[!] Usage: usbarsenal -t <Target OS> -f <USB Functions> -v <idVendor value> -p <idProduct value> [mPs]"
    bklog "[!] Available target OS: [win|lnx|mac]; win => Windows; lnx => Linux; mac => Mac OS"
    bklog "[!] Available configfs functions: [reset] or [adb,hid,mass_storage,rndis,acm,ecm]"
    bklog "[!] reset => enable adb only."
    bklog "[!] hid => enable HID only."
    bklog "[!] mass_storage => enable mass storage only."
    bklog "[!] rndis => enable RNDIS only, usually target on Windows or Linux."
    bklog "[!] acm,ecm => enable network card simulation on Mac OS when these two are enabled together.\n"
    bklog "[!] e.g. \"usbarsenal -t win -f reset -v '0x18d1' -p '0x4ee7'\""
    bklog "[!] e.g. \"usbarsenal -t win -f adb,hid,mass_storage,rndis -v '0x18d1' -p '0x4a4a'\""
    bklog "[!] e.g. \"usbarsenal -t mac -f adb,hid,mass_storage,acm,ecm -v '0x18d1' -p '0x4b4b'\""
}

function join_by(){
    local IFS="$1"; shift; echo "$*";
}

function switch_funcs(){
    local TARGET_OS=$1
    local TARGET_FUNCS=$2
    local ARRAY_TARGET_FUNCS
    local FUNCS_DESC

    # some nastry ticks
    [ -z "$MANUFACTURER" ] && MANUFACTURER="OffSec"
    [ -z "$PRODUCT" ] && PRODUCT="NetHunter"
    [ -z "$SERIALNUMBER" ] && SERIALNUMBER="1337H4X0R"

    ## Setup the idProduct, idVendor, manufacturer, product, serialnumber
    setprop offsec.nethunter.idVendor "$ID_VENDOR"
    setprop offsec.nethunter.idProduct "$ID_PRODUCT"

    [ ! -z "$MANUFACTURER" ] && [ -f $DIR_CONFIGFS/strings/0x409/manufacturer ] && echo "$MANUFACTURER" | tee $DIR_CONFIGFS/strings/0x409/manufacturer
    [ ! -z "$PRODUCT" ] && [ -f $DIR_CONFIGFS/strings/0x409/product ] && echo "$PRODUCT" | tee $DIR_CONFIGFS/strings/0x409/product
    [ ! -z "$SERIALNUMBER" ] && [ -f $DIR_CONFIGFS/strings/0x409/serialnumber ] && echo "$SERIALNUMBER" | tee $DIR_CONFIGFS/strings/0x409/serialnumber

    ## If the target function is "reset" then use adb setprop directly ##
    if [ "$TARGET_FUNCS" = "reset" ]; then
        bklog "[!] Resetting the usb functions to adb only."
        setprop sys.usb.config none; sleep 3
        echo "SAMSUNG" | tee $DIR_CONFIGFS/strings/0x409/manufacturer
        echo "SAMSUNG_Android" | tee $DIR_CONFIGFS/strings/0x409/product
        echo "$(getprop ro.serialno)" | tee $DIR_CONFIGFS/strings/0x409/serialnumber
        setprop sys.usb.config adb
        exit 0
    fi

    ## Remove all spaces of user's input, and then put it into array ##
    TARGET_FUNCS=$(echo ${TARGET_FUNCS//[[:space:]]})
    IFS=','; ARRAY_TARGET_FUNCS=($TARGET_FUNCS); unset IFS

    ## Re-introduce the state variables from the original script ##
    ## Initialize to 1 (false / not selected)
    IS_ADB_SELECTED=1
    IS_HID_SELECTED=1
    IS_MASS_SELECTED=1
    IS_RNDIS_SELECTED=1
    IS_ACM_SELECTED=1
    IS_ECM_SELECTED=1

    ## Build the setprop config string and set state variables ##
    local CONFIG_STRING=""
    local FIRST_FUNC=1
    
    for i in ${ARRAY_TARGET_FUNCS[@]}; do
        case "$i" in
            adb)
                IS_ADB_SELECTED=0
                ;;
            hid)
                IS_HID_SELECTED=0
                ;;
            mass_storage)
                IS_MASS_SELECTED=0
                ;;
            rndis)
                IS_RNDIS_SELECTED=0
                ;;
            acm)
                IS_ACM_SELECTED=0
                ;;
            ecm)
                IS_ECM_SELECTED=0
                ;;
        esac
    done
    
    # We can now just use the original input for the config string
    CONFIG_STRING=$(echo "$TARGET_FUNCS" | sed 's/ //g')

    ## If no functions selected, default to adb ##
    if [ -z "$CONFIG_STRING" ]; then
        CONFIG_STRING="adb"
        IS_ADB_SELECTED=0
    fi

    # Prepend the "nethunter" namespace to the config string
    CONFIG_STRING="nethunter,${CONFIG_STRING}"

    bklog "[!] Setting USB configuration: ${CONFIG_STRING}"
    
    ## Use setprop to change USB configuration - init.rc handles the rest ##
    setprop sys.usb.config none; sleep 3
    setprop sys.usb.config "$CONFIG_STRING"

    ## Wait for the configuration to fully apply ##
    sleep 2

    ## Perform conditional actions based on the state variables ##
    ## This is the section other scripts (and the app) depend on.
    if [ "$IS_HID_SELECTED" -eq 0 ]; then
        if [ -c /dev/hidg0 ] && [ -c /dev/hidg1 ]; then
            bklog "[+] HID function enabled. Setting permissions for /dev/hidg*."
            chmod 666 /dev/hidg0 /dev/hidg1
        else
            bklog "[-] HID was selected, but /dev/hidg0 or /dev/hidg1 not found."
        fi
    fi
    
    # NOTE: You can now export these variables if other child scripts need them
    export IS_ADB_SELECTED IS_HID_SELECTED IS_MASS_SELECTED IS_RNDIS_SELECTED IS_ACM_SELECTED IS_ECM_SELECTED

    ## Build description for logging ##
    FUNCS_DESC=$(join_by _ "${ARRAY_TARGET_FUNCS[@]}")

    bklog "[+] Done. Enabled functions: $FUNCS_DESC"
}

###################
#### Main Part ####
###################

## Parse the args first. ##
while getopts "t:f:v:p:m:P:s:" OPTS; do
    case $OPTS in
        t) TARGET_OS=$OPTARG;;
        f) TARGET_FUNCS=$OPTARG;;
        v) ID_VENDOR=$OPTARG;;
        p) ID_PRODUCT=$OPTARG;;
        m) MANUFACTURER=$OPTARG;;
        P) PRODUCT=$OPTARG;;
        s) SERIALNUMBER=$OPTARG;;
        *) print_usage; exit 1;;
    esac
done

## The number of args should be exactly 8 ##
if [ -z "$TARGET_OS" -o -z "$TARGET_FUNCS" -o -z "$ID_VENDOR" -o -z "$ID_PRODUCT" ]; then
    print_usage; exit 1
fi

## The target OS should only be "win" -> Windows, "lnx" -> Linux, "mac" -> Mac OS ##
if [ ! "$TARGET_OS" = "win" -a ! "$TARGET_OS" = "lnx" -a ! "$TARGET_OS" = "mac" ]; then
    print_usage; exit 1
fi

bklog "[!] You got ${#ORI_FUNCS[@]} function(s) enabled now."
bklog "[!] They are: ${ORI_FUNCS[@]}"

switch_funcs $TARGET_OS $TARGET_FUNCS
