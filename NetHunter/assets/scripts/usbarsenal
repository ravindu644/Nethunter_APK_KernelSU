#!/system/bin/sh

## Important note:
## Only works with exynos9820 devices with ravindu644's .rc file

SCRIPT_PATH=$(readlink -f $0)
. ${SCRIPT_PATH%/*}/bootkali_log
. ${SCRIPT_PATH%/*}/bootkali_env


USB_RC="/vendor/etc/init/init.$(getprop ro.hardware).usb.rc"

if grep -q "nethunter" "$USB_RC"; then
    bklog "[!] Custom Nethunter build by ravindu644 for exynos9820/9825."
else
    bklog "[-] This specific script will only work with ravindu644's custom usb.rc file."
    exit 1
fi

#################################
#### Define global variables ####
#################################
ORI_DWC=$(getprop sys.usb.controller)
DIR_CONFIGFS=/config/usb_gadget/g1
DIR_ALL_FUNCS=$DIR_CONFIGFS/functions
DIR_CUR_FUNCS=$DIR_CONFIGFS/configs/b.1

## Get what functions the user are using, and list them in ascending order.
ORI_FUNCS_UNSORT=($($BUSYBOX find $DIR_CUR_FUNCS -type l))
ORI_FUNCS=($(printf '%s\n' "${ORI_FUNCS_UNSORT[@]}" | $BUSYBOX sort -n))

## Make sure user at least has one usb functions enabled,
## otherwise it cannot be determined what prefix name and the first instance number should be used.
if [ -z "$ORI_FUNCS" ]; then
    bklog "[-] No symlinked function is found in $DIR_CUR_FUNCS, something is wrong, aborting.."
    exit 1
fi

## Seperate the prefix name and the instance order.
FUNCS_NAME_PREFIX=$(echo ${ORI_FUNCS[0]} | $BUSYBOX sed 's/\(^.*\)\(\/\([a-zA-Z]\{1,\}\)[0-9]\{1,\}$\)/\3/g')
FUNCS_NAME_ORDER=$(echo ${ORI_FUNCS[0]} | $BUSYBOX sed 's/\(^.*\)\(\/[a-zA-Z]\{1,\}\([0-9]\{1,\}\)$\)/\3/g')

## Define the first function name that will be symlinked to $DIR_CUR_FUNCS
SYMLINK_FUNC_NAME="${FUNCS_NAME_PREFIX}${FUNCS_NAME_ORDER}"

################################
#### Define shell functions ####
################################

function print_usage(){
    bklog "[!] Usage: usbarsenal -t <Target OS> -f <USB Functions> -v <idVendor value> -p <idProduct value> [mPs]"
    bklog "[!] Available target OS: [win|lnx|mac]; win => Windows; lnx => Linux; mac => Mac OS"
    bklog "[!] Available configfs functions: [reset] or [adb,hid,mass_storage,rndis,acm,ecm]"
    bklog "[!] reset => enable adb only."
    bklog "[!] hid => enable HID only."
    bklog "[!] mass_storage => enable mass storage only."
    bklog "[!] rndis => enable RNDIS only, usually target on Windows or Linux."
    bklog "[!] acm,ecm => enable network card simulation on Mac OS when these two are enabled together.\n"
    bklog "[!] e.g. \"usbarsenal -t win -f reset -v '0x18d1' -p '0x4ee7'\""
    bklog "[!] e.g. \"usbarsenal -t win -f adb,hid,mass_storage,rndis -v '0x18d1' -p '0x4a4a'\""
    bklog "[!] e.g. \"usbarsenal -t mac -f adb,hid,mass_storage,acm,ecm -v '0x18d1' -p '0x4b4b'\""
}

function join_by(){
    local IFS="$1"; shift; echo "$*";
}

function switch_funcs(){
    local TARGET_OS=$1
    local TARGET_FUNCS=$2
    local ARRAY_TARGET_FUNCS
    local FUNCS_DESC

    ## Setup the idProduct, idVendor, manufacturer, product, serialnumber
    setprop offsec.nethunter.idVendor "$ID_VENDOR"
    setprop offsec.nethunter.idProduct "$ID_PRODUCT"

    ### Changing manufacturer, product, serialnumber may make your PC fail to authen your device again, ##
    ## so this part is disabled now until further experiment. ##
    [ ! -z "$MANUFACTURER" ] && [ -f $DIR_CONFIGFS/strings/0x409/manufacturer ] && setprop offsec.nethunter.manufacturer "$MANUFACTURER"
    [ ! -z "$PRODUCT" ] && [ -f $DIR_CONFIGFS/strings/0x409/product ] && setprop offsec.nethunter.product "$PRODUCT"
    [ ! -z "$SERIALNUMBER" ] && [ -f $DIR_CONFIGFS/strings/0x409/serialnumber ] && setprop offsec.nethunter.serialnumber "$SERIALNUMBER"

    ## If the target function is "reset" then use adb setprop directly ##
    if [ "$TARGET_FUNCS" = "reset" ]; then
        bklog "[!] Resetting the usb functions to adb only."
        setprop sys.usb.config adb
        exit 0
    fi

    ## Remove all spaces of user's input, and then put it into array ##
    TARGET_FUNCS=$(echo ${TARGET_FUNCS//[[:space:]]})
    IFS=','; ARRAY_TARGET_FUNCS=($TARGET_FUNCS); unset IFS

    ## Build the setprop config string based on selected functions ##
    local CONFIG_STRING=""
    local FIRST_FUNC=1
    
    for i in ${ARRAY_TARGET_FUNCS[@]}; do
        case "$i" in
            adb|hid|mass_storage|rndis|acm|ecm)
                if [ $FIRST_FUNC -eq 1 ]; then
                    CONFIG_STRING="$i"
                    FIRST_FUNC=0
                else
                    CONFIG_STRING="${CONFIG_STRING},$i"
                fi
                FUNCS_DESC+=("$i")
                ;;
        esac
    done

    ## If no functions selected, default to adb ##
    if [ -z "$CONFIG_STRING" ]; then
        CONFIG_STRING="adb"
        FUNCS_DESC+=('adb')
    fi

    # MODIFICATION HERE: Prepend the "nethunter" namespace to the config string
    CONFIG_STRING="nethunter,${CONFIG_STRING}"

    bklog "[!] Setting USB configuration: ${CONFIG_STRING}"
    
    ## Use setprop to change USB configuration - init.rc handles the rest ##
    setprop sys.usb.config "$CONFIG_STRING"

    ## Wait for the configuration to fully apply ##
    sleep 4

    ## Build description for logging ##
    FUNCS_DESC=$(join_by _ "${FUNCS_DESC[@]}")

    bklog "[+] Done."
}

###################
#### Main Part ####
###################

## Parse the args first. ##
while getopts "t:f:v:p:m:P:s:" OPTS; do
    case $OPTS in
        t) TARGET_OS=$OPTARG;;
        f) TARGET_FUNCS=$OPTARG;;
        v) ID_VENDOR=$OPTARG;;
        p) ID_PRODUCT=$OPTARG;;
        m) MANUFACTURER=$OPTARG;;
        P) PRODUCT=$OPTARG;;
        s) SERIALNUMBER=$OPTARG;;
        *) print_usage; exit 1;;
    esac
done

## The number of args should be exactly 8 ##
if [ -z "$TARGET_OS" -o -z "$TARGET_FUNCS" -o -z "$ID_VENDOR" -o -z "$ID_PRODUCT" ]; then
    print_usage; exit 1
fi

## The target OS should only be "win" -> Windows, "lnx" -> Linux, "mac" -> Mac OS ##
if [ ! "$TARGET_OS" = "win" -a ! "$TARGET_OS" = "lnx" -a ! "$TARGET_OS" = "mac" ]; then
    print_usage; exit 1
fi

bklog "[!] You got ${#ORI_FUNCS[@]} function(s) enabled now."
bklog "[!] They are: ${ORI_FUNCS[@]}"

switch_funcs $TARGET_OS $TARGET_FUNCS
